NODE_MODULES_BIN := ./node_modules/.bin
NPM := npm
TSC := $(NODE_MODULES_BIN)/tsc
DOCKER_COMPOSE := docker-compose

SERVER_SRCS := $(wildcard server/*.ts) $(wildcard server/*/*.ts)
SERVER_OUTS := $(subst server/,dist/,$(SERVER_SRCS:.ts=))

.PHONY: all clean install install-prod build-server build build-docker

all: build

# Removes all files generated by the build (except node_modules)
clean:
	rm -rf dist

# Installs all dependencies
install: package.json
	$(NPM) install

# Installs only production dependencies
install-prod:
	$(NPM) install --production

# Target to install node_modules if depended upon by other targets
node_modules: package.json
	[ -e node_modules ] || $(NPM) install

# Builds the server code (using typescript)
build-server: $(addsuffix .js,$(SERVER_OUTS))

$(addsuffix %js, $(SERVER_OUTS)): node_modules server/tsconfig.json $(SERVER_SRCS)
	$(TSC) --project server

# Builds the entire app (excluding docker containers)
build: build-server

# Builds a production docker container
build-docker: build
	$(DOCKER_COMPOSE) build

# Starts a production docker container (listens on port 8080)
start-docker: build
	$(DOCKER_COMPOSE) up web

# Starts a docker container for development
# This listens for http on port 8080, and listens for node debug on
# port 9229 (--inspect protocol)
# This also starts the Typescript compiler (tsc) and watches all typescript
# files for changes. When the files are changed, they will be compiled and
# then the server will restart.
start-docker-dev: node_modules
	$(DOCKER_COMPOSE) build
	$(TSC) --project server --watch &
	$(DOCKER_COMPOSE) -f docker-compose.dev.yml up web
